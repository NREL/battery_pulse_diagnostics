"""
Helper functions for processing data.
"""

import numpy as np
import pandas as pd
from scipy import integrate
from sklearn.preprocessing import LabelEncoder, StandardScaler
from tsfresh import select_features

pd.options.mode.chained_assignment = None


TARGETS = [
    "1C discharge capacity",
    "C/10 discharge capacity",
    "C/5 discharge capacity",
    "C/3 discharge capacity",
    "C/2 discharge capacity",
    "P/3 discharge capacity",
    "Charge depleting cycle charge throughput",
    "Charge sustaining cycle charge efficiency",
    "soc",
    "Post 1C charge relaxation fit MSE",
    "Post 1C charge relaxation fit MSE_outlier",
    "C/3 discharge capacity * SOC",
]


THRESHOLDS_1C = {
    "A": 3.6e-6,
    "B": 0.0000165,
    "C": 2.5e-06,
}

THRESHOLDS_C_2 = {
    "A": 3.6e-6,
    "B": 0.0000275,
    "C": 5.7e-06,
}


def make_binary(
    df: pd.DataFrame, original_target: str, threshold: float, tag: str = "_outlier"
):
    """
    Binarize a continuous feature by setting all values
    less than a given threshold to 0 and all values above
    the given threshold to 1. Add the binarized feature
    as a new column in df, with the suffix `tag` appended
    to the original name.

    Args:
        df (pd.DataFrame): Set of all data
        original_target (str): Name of variable
                               in df to binarize
        threshold (float): Binarization threshold
        tag (str): Suffix for new binarized feature.

    Return:
        pd.DataFrame
    """
    target = f"{original_target}{tag}"
    df.loc[df[original_target] >= threshold, target] = 1
    df.loc[df[original_target] < threshold, target] = 0
    return df


### Helper functions for processing data for XGBoost ###
def filter_relevant_extracted_features(
    train: pd.DataFrame,
    test: pd.DataFrame,
    target: str,
):
    """
    Use TSFresh's `select_features()` function to downselect
    extracted features to the most relevant ones, based on the
    train set.

    Args:
        train (pd.DataFrame): Train dataframe
        test (pd.DataFrame): Train dataframe
        target (str): Name of target variable

    Return:
        pd.DataFrame: Train dataframe with subset
                      of relevant features.
        pd.DataFrame: Test dataframe with subset
                      of relevant features.

    """

    relevant_features = select_features(
        train.filter(regex="voltage|current|polarization"), train[target]
    )
    original_features = train.filter(regex="voltage|current|polarization").columns
    cols_to_drop = list(set(original_features) - set(relevant_features.columns))
    train = train.drop(columns=cols_to_drop)
    test = test.drop(columns=cols_to_drop)
    return train, test


def filter_cell_type(df, cell_type):
    """
    Filter dataframe for cell type A, B, or C.

    Args:
        df (pd.DataFrame):  Dataframe to filter.
                            Expected to have column "cell_id".
        cell_type (str):    Cell type identifier to filter for.

    Returns:
        pd.DataFrame: df filtered for rows where
                      "cell_id" starts with `cell_type`.
    """
    cell_df = df[df["cell_id"].str.startswith(cell_type)]
    return cell_df.reset_index(drop=True)


def load_data(filename: str = "data_for_ml.h5", cell_type: str = None):
    """
    Process data from h5 file into dictionary where keys are
    pulse types and values are dataframes of features/targets.

    Args:
        filename:   Path to h5 file generated by 05_process_data_for_ml.py
        cell_type:  One of {None, "A", "B", "C"}. If provided,
                    filters data only for that cell type.

    Return:
        tests:      Dictionary of feature/target data where each
                    key is a pulse measurement type.
    """

    data = pd.HDFStore(filename)

    static_hppc = data.get("Static_HPPC")
    static_rapid = data.get("Static_Rapid")
    static_psrp1 = data.get("Static_PsRP_1")
    static_psrp2_chg = data.get("Static_PsRP_2_Chg")
    static_psrp2_dis = data.get("Static_PsRP_2_Dis")
    dynamic_psrp1_Cb2 = data.get("Dynamic_PsRP_1_C/2")
    dynamic_psrp1_1C = data.get("Dynamic_PsRP_1_1C")
    dynamic_psrp2_Cb2 = data.get("Dynamic_PsRP_2_C/2")
    dynamic_psrp2_1C = data.get("Dynamic_PsRP_2_1C")

    if cell_type is not None:
        static_hppc = filter_cell_type(static_hppc, cell_type)
        static_rapid = filter_cell_type(static_rapid, cell_type)
        static_psrp1 = filter_cell_type(static_psrp1, cell_type)
        static_psrp2_chg = filter_cell_type(static_psrp2_chg, cell_type)
        static_psrp2_dis = filter_cell_type(static_psrp2_dis, cell_type)
        dynamic_psrp1_Cb2 = filter_cell_type(dynamic_psrp1_Cb2, cell_type)
        dynamic_psrp1_1C = filter_cell_type(dynamic_psrp1_1C, cell_type)
        dynamic_psrp2_Cb2 = filter_cell_type(dynamic_psrp2_Cb2, cell_type)
        dynamic_psrp2_1C = filter_cell_type(dynamic_psrp2_1C, cell_type)

    tests = {
        "Static HPPC": static_hppc,
        "Static Rapid": static_rapid,
        "Static PsRP 1": static_psrp1,
        "Static PsRP 2 Chg": static_psrp2_chg,
        "Static PsRP 2 Dis": static_psrp2_dis,
        "Dynamic PsRP 1 C/2": dynamic_psrp1_Cb2,
        "Dynamic PsRP 1 1C": dynamic_psrp1_1C,
        "Dynamic PsRP 2 C/2": dynamic_psrp2_Cb2,
        "Dynamic PsRP 2 1C": dynamic_psrp2_1C,
    }

    if "/DCIR" in data.keys():
        dcir = data.get("DCIR")
        if cell_type is not None:
            dcir = filter_cell_type(dcir, cell_type)
        tests["DCIR"] = dcir

    data.close()

    ### Add some additional features and targets ###
    for test in tests:

        # Give each row a unique "sample_id"
        tests[test]["sample_id"] = tests[test].index

        # Add polarization feature (V - V0)
        if test != "DCIR":
            voltage_cols = tests[test].filter(regex="voltage").columns
            for v in voltage_cols:
                tests[test][f"polarization_{v.split('_')[1]}"] = (
                    tests[test][v] - tests[test][voltage_cols[0]]
                )

        # Make Excess electrolyte categorical
        le = LabelEncoder()
        mask = tests[test]["Excess electrolyte"].isna()
        tests[test]["Excess electrolyte"] = le.fit_transform(
            tests[test]["Excess electrolyte"]
        )
        tests[test]["Excess electrolyte"][mask] = np.nan

        # Add C/3 discharge * SOC target
        c_3_discharge = tests[test]["C/3 discharge capacity"]
        soc = tests[test]["soc"]
        tests[test]["C/3 discharge capacity * SOC"] = c_3_discharge * soc

        # Binarize safety to use for binary classification
        if cell_type is not None and cell_type != "D":
            # Using post-1C charge
            original_target = "Post 1C charge relaxation fit MSE"
            tests[test] = make_binary(
                tests[test],
                original_target,
                threshold=THRESHOLDS_1C[cell_type],
                tag="_outlier",
            )

            # Using post-2C charge
            original_target = "Post C/2 charge relaxation fit MSE"
            tests[test] = make_binary(
                tests[test],
                original_target,
                threshold=THRESHOLDS_C_2[cell_type],
                tag="_outlier",
            )

            # Using post-1C OR post-2C charge
            tests[test]["Post 1C or Post C/2_outlier"] = tests[test][
                "Post 1C charge relaxation fit MSE_outlier"
            ].astype(int) | tests[test][
                "Post C/2 charge relaxation fit MSE_outlier"
            ].astype(
                int
            )

        # Set up categorical bins ("good", "okay", and "bad") for capacity values
        thresholds = {
            "A": [0.80 * 64, 0.90 * 64],
            "B": [0.70 * 66, 0.80 * 66],
            "C": [0.80 * 26, 0.90 * 26],
            "D": [0.80 * 2.5, 0.90 * 2.5],
        }
        if cell_type is not None:
            for original_target in ["1C discharge capacity", "C/3 discharge capacity"]:
                tests[test][f"{original_target}_3bins"] = np.digitize(
                    tests[test][original_target], bins=thresholds[cell_type]
                )

    return tests


### Helper function for processing data for deep learning ###
def format_data_for_nn(data: dict, targets: list[str]):
    """
    Args:
        data (dict):    Dictionary returned by `load_data()`
        target (list):  List of target names to save

    Returns:
        data_for_nn (dict): Dictionary with same keys as `data`
                            with features/targets formatted for
                            deep learning
    """

    target_regex = "|".join(targets)
    data_for_ml = dict()
    for key in data:
        if key == "DCIR":
            continue
        df = data[key]
        vs = df.filter(regex="voltage.*").to_numpy()
        cs = df.filter(regex="current.*").to_numpy()
        ps = df.filter(regex="polarization.*").to_numpy()
        temps = df.filter(
            regex="temperature.*"
        ).to_numpy()  # .drop(columns=['temperature_ambient']).to_numpy()

        vs = StandardScaler().fit_transform(vs)
        cs = StandardScaler().fit_transform(cs)
        ps = StandardScaler().fit_transform(ps)
        temps = StandardScaler().fit_transform(temps)
        temps = np.stack([temps] * vs.shape[-1], axis=-1).squeeze()

        X = np.stack([vs, cs, ps, temps], axis=-1)
        y = df.filter(regex=target_regex)
        metadata = df.filter(regex="measurement_id|sample_id|soc|temperature|direction")
        if len(y) == 0:
            raise ValueError(f"Regex {target_regex} not found in {key}.")
        data_for_ml[key] = {"X": X, "y": y, "metadata": metadata}
    return data_for_ml


def get_capacity(df):
    """
    Extract capacity from measurement data. If it's a CC-CV measurement
    (two separate steps), return the CC, CV, and CC-CV capacity.
    NOTE: The input data frame should ONLY have the measurement data.

    Args:
        df (pd.DataFrame): Measurement data

    Returns:
        np.ndarray: Capacity values
    """
    steps = np.unique(df["Step"])
    capacity = np.zeros(steps.size)
    for i, step in enumerate(steps):
        mask_step = df["Step"] == step
        cap = np.abs(df.loc[mask_step, "Amp-Hours, AH"])
        cap = np.max(cap)
        capacity[i] = cap
    if steps.size > 1:
        capacity = np.append(capacity, np.sum(capacity))
    return capacity


def get_segment_parts(df):
    """
    Return separate data frames of each segment part, for segments that repeat.

    Args:
        df (pd.DataFrame): Measurement data
    """
    df = df.reset_index(drop=True)
    # Search for any discontinuities in the times. Voltage sampling rate should always be less than or equal to 10 seconds
    segment_starts = np.argwhere(np.diff(df["Total Time, S"], prepend=0) > 11).squeeze()
    segs = []
    for i, idx in enumerate(segment_starts):
        # Extract this segment part
        if i == segment_starts.size - 1:
            df_seg_part = df.loc[idx:].copy().reset_index(drop=True)
        else:
            df_seg_part = (
                df.loc[idx : segment_starts[i + 1] - 1].copy().reset_index(drop=True)
            )
        df_seg_part = retime(df_seg_part)
        segs.append(df_seg_part)
    return segs


def retime(df):
    """
    Recalculate segment time, treating the entire dataframe as one segment.

    Args:
        df (pd.DataFrame): Measurement data. Includes a column
                           'Segment Time, S'

    Returns:
        pd.DataFrame: Dataframe where 'Segment Time, S' is reindexed
                      to start from 0.
    """
    df_ = df.copy().reset_index(drop=True)
    df_["Segment Time, S"] = df_["Total Time, S"] - df_.loc[0, "Total Time, S"]
    return df_


def get_discharge_capacities(df):
    """
    Return capacities and metadata (rate, max/min/avg temperature).
    """
    segments = [
        "Rate test 1C cycle discharge",
        "Rate test C/10 cycle discharge",
        "Rate test C/2 cycle discharge",
        "Rate test C/3 cycle discharge",
        "Rate test C/5 cycle discharge",
        "Rate test P/3 cycle discharge",
    ]
    rates = [
        "1C",
        "C/10",
        "C/2",
        "C/3",
        "C/5",
        "P/3",
    ]
    for i, segment in enumerate(segments):
        mask = [segment in seg_desc for seg_desc in df["Segment Description"]]
        df_ = df[mask].copy()
        capacity = get_capacity(df_)
        rate = rates[i]
        temp_max = np.max(df_["Temperature A1, °C"])
        temp_min = np.min(df_["Temperature A1, °C"])
        temp_mean = np.mean(df_["Temperature A1, °C"])
        conc_grad_max = np.max(get_concentration_gradient(df_))
        dat = {
            "segment": segment,
            "discharge capacity CC": capacity[0],
            "discharge capacity CV": capacity[1],
            "discharge capacity CC-CV": capacity[2],
            "rate": rate,
            "temp_max": temp_max,
            "temp_min": temp_min,
            "temp_mean": temp_mean,
            "conc_grad_max": conc_grad_max,
        }
        if i == 0:
            out = pd.DataFrame(dat, index=[i])
        else:
            _out = pd.DataFrame(dat, index=[i])
            out = pd.concat([out, _out])
    return out


def get_discharge_capacities_cc(df):
    # Retun the capacities and the meta-data: rate, max/min/avg temperature
    segments = [
        "Rate test C/10 cycle discharge",
        "Rate test C/5 cycle discharge",
        "Rate test C/3 cycle discharge",
        "Rate test C/2 cycle discharge",
        "Rate test 1C cycle discharge",
        "Rate test P/3 cycle discharge",
    ]
    rates = np.array([1 / 10, 1 / 5, 1 / 3, 1 / 2, 1, 1 / 3])
    for i, segment in enumerate(segments):
        mask = [segment in seg_desc for seg_desc in df["Segment Description"]]
        df_ = df[mask].copy()
        capacity = get_capacity(df_)
        rate = rates[i]
        temp_max = np.max(df_["Temperature A1, °C"])
        temp_min = np.min(df_["Temperature A1, °C"])
        temp_mean = np.mean(df_["Temperature A1, °C"])
        dat = {
            "segment": segment,
            "discharge capacity": capacity[0],
            "rate": rate,
            "temp_max": temp_max,
            "temp_min": temp_min,
            "temp_mean": temp_mean,
        }
        if i == 0:
            out = pd.DataFrame(dat, index=[i])
        else:
            _out = pd.DataFrame(dat, index=[i])
            out = pd.concat([out, _out])
    return out


def get_charge_capacities(df):
    # Retun the capacities and the meta-data: rate, max/min/avg temperature
    segments = [
        "Rate test 1C cycle charge",
        "Rate test C/10 cycle charge",
        "Rate test C/2 cycle charge",
        "Rate test C/3 cycle charge",
        "Rate test C/5 cycle charge",
        "Rate test P/3 cycle charge",
    ]
    rates = [
        "1C",
        "C/10",
        "C/2",
        "C/3",
        "C/5",
        "P/3",
    ]
    for i, segment in enumerate(segments):
        mask = [segment in seg_desc for seg_desc in df["Segment Description"]]
        df_ = df[mask].copy()
        capacity = get_capacity(df_)
        rate = rates[i]
        temp_max = np.max(df_["Temperature A1, °C"])
        temp_min = np.min(df_["Temperature A1, °C"])
        temp_mean = np.mean(df_["Temperature A1, °C"])
        conc_grad_max = np.max(get_concentration_gradient(df_))
        dat = {
            "segment": segment,
            "discharge capacity CC": capacity[0],
            "discharge capacity CV": capacity[1],
            "discharge capacity CC-CV": capacity[2],
            "rate": rate,
            "temp_max": temp_max,
            "temp_min": temp_min,
            "temp_mean": temp_mean,
            "conc_grad_max": conc_grad_max,
        }
        if i == 0:
            out = pd.DataFrame(dat, index=[i])
        else:
            _out = pd.DataFrame(dat, index=[i])
            out = pd.concat([out, _out])
    return out


def get_concentration_gradient(df):
    # Calculate cumulative integral of current * sqrt(time) for a segment
    # A proxy for estimating the concentration gradient from Kandler (denso JES paper)
    # max of value is a good feature for predicting fade (adam thelen paper)
    df = retime(df)
    current = df["Current, A"]
    sqrt_time = np.sqrt(df["Segment Time, S"])
    conc_grad = integrate.cumtrapz(current * sqrt_time, df["Segment Time, S"])
    return conc_grad


def get_hppc_pulse_resistances(df):
    # processes all pulses from charge and discharge HPPCs

    # ohms law pulse resistance, return vector from all voltage data
    # return metadata soc, temp_mean
    # return charge, discharge, average

    #'Cell Voltage A1, V'	'Cell Voltage A2, V'	'Cell Voltage A3, V'
    if any(["Cell Voltage A1" in col for col in df.columns]):
        flag_series_voltages = True
        col_voltage = "Cell Voltage A1, V"
    else:
        flag_series_voltages = False
        col_voltage = "Voltage, V"

    is_pulse = [
        "HPPC" in seg_desc and "pulses" in seg_desc and not "rapid" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)
    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    for ii, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            steps = np.unique(df_seg["Step"])
            for i, step in enumerate(steps):
                mask_step = df_seg["Step"] == step
                mask_step = mask_step.to_numpy()
                if ii == 0:
                    idx = np.argwhere(is_pulse).squeeze() - 1
                    prior_voltage = df.loc[idx[0], col_voltage]
                    if flag_series_voltages:
                        prior_voltage_group1 = df.loc[idx[0], "Cell Voltage A2, V"]
                        prior_voltage_group2 = df.loc[idx[0], "Cell Voltage A3, V"]
                else:
                    # Get element of the immediately prior voltage value
                    mask_priorvoltage = [False] * len(mask_step)
                    in_chunk = False
                    for i, value in enumerate(mask_step):
                        if value and not in_chunk:
                            mask_priorvoltage[i - 1] = True
                            in_chunk = True
                        elif not value:
                            in_chunk = False
                    prior_voltage = df_seg.loc[
                        mask_priorvoltage, col_voltage
                    ].to_numpy()
                    prior_voltage = prior_voltage[0]
                    if flag_series_voltages:
                        prior_voltage_group1 = df_seg.loc[
                            mask_priorvoltage, "Cell Voltage A2, V"
                        ].to_numpy()
                        prior_voltage_group1 = prior_voltage_group1[0]
                        prior_voltage_group2 = df_seg.loc[
                            mask_priorvoltage, "Cell Voltage A3, V"
                        ].to_numpy()
                        prior_voltage_group2 = prior_voltage_group2[0]

                soc = df_seg["SOC"].to_numpy()
                soc = soc[0]
                df_step = df_seg[mask_step].copy().reset_index()
                if not "REST" in df_step.loc[0, "Mode"]:
                    current = df_step["Current, A"].to_numpy()
                    max_current = np.max(np.abs(current))
                    voltage = df_step[col_voltage].to_numpy()
                    overpotential = np.abs(voltage - prior_voltage)
                    if flag_series_voltages:
                        voltage_group1 = df_step["Cell Voltage A2, V"].to_numpy()
                        overpotential_group1 = np.abs(
                            voltage_group1 - prior_voltage_group1
                        )
                        voltage_group2 = df_step["Cell Voltage A3, V"].to_numpy()
                        overpotential_group2 = np.abs(
                            voltage_group2 - prior_voltage_group2
                        )
                    time = df_step["Segment Time, S"].to_numpy()
                    time = time - time[0] + 0.1
                    if np.sign(np.mean(current)) == 1:
                        charge_current = current
                        charge_voltage = voltage
                        charge_overpotential = overpotential
                        charge_resistance = overpotential / max_current
                        charge_resistance_0p1s = charge_resistance[
                            np.isclose(time, 0.1)
                        ]
                        charge_resistance_1s = charge_resistance[np.isclose(time, 1)]
                        charge_resistance_4s = charge_resistance[np.isclose(time, 4)]
                        if np.max(time) > 5:
                            charge_resistance_10s = charge_resistance[
                                np.isclose(time, 10)
                            ]
                        else:
                            charge_resistance_10s = np.NaN
                        is_voltage_limit_charge = (
                            max_current - np.abs(current[-1])
                        ) > 0.1
                        if flag_series_voltages:
                            # repeat the above twice for each parallel group voltage
                            # group1
                            charge_voltage_group1 = voltage_group1
                            charge_overpotential_group1 = overpotential_group1
                            charge_resistance = overpotential_group1 / max_current
                            charge_resistance_group1_0p1s = charge_resistance[
                                np.isclose(time, 0.1)
                            ]
                            charge_resistance_group1_1s = charge_resistance[
                                np.isclose(time, 1)
                            ]
                            charge_resistance_group1_4s = charge_resistance[
                                np.isclose(time, 4)
                            ]
                            if np.max(time) > 5:
                                charge_resistance_group1_10s = charge_resistance[
                                    np.isclose(time, 10)
                                ]
                            else:
                                charge_resistance_group1_10s = np.NaN
                            # group2
                            charge_voltage_group2 = voltage_group2
                            charge_overpotential_group2 = overpotential_group2
                            charge_resistance = overpotential_group2 / max_current
                            charge_resistance_group2_0p1s = charge_resistance[
                                np.isclose(time, 0.1)
                            ]
                            charge_resistance_group2_1s = charge_resistance[
                                np.isclose(time, 1)
                            ]
                            charge_resistance_group2_4s = charge_resistance[
                                np.isclose(time, 4)
                            ]
                            if np.max(time) > 5:
                                charge_resistance_group2_10s = charge_resistance[
                                    np.isclose(time, 10)
                                ]
                            else:
                                charge_resistance_group2_10s = np.NaN
                    else:
                        discharge_current = current
                        discharge_voltage = voltage
                        discharge_overpotential = overpotential
                        discharge_resistance = overpotential / max_current
                        discharge_resistance_0p1s = discharge_resistance[
                            np.isclose(time, 0.1)
                        ]
                        discharge_resistance_1s = discharge_resistance[
                            np.isclose(time, 1)
                        ]
                        discharge_resistance_4s = discharge_resistance[
                            np.isclose(time, 4)
                        ]
                        if np.max(time) > 5:
                            discharge_resistance_10s = discharge_resistance[
                                np.isclose(time, 10)
                            ]
                        else:
                            discharge_resistance_10s = np.NaN
                        is_voltage_limit_discharge = (
                            max_current - np.abs(current[-1])
                        ) > 0.1
                        if flag_series_voltages:
                            # repeat the above twice for each parallel group voltage
                            # group1
                            discharge_voltage_group1 = voltage_group1
                            discharge_overpotential_group1 = overpotential_group1
                            discharge_resistance = overpotential_group1 / max_current
                            discharge_resistance_group1_0p1s = discharge_resistance[
                                np.isclose(time, 0.1)
                            ]
                            discharge_resistance_group1_1s = discharge_resistance[
                                np.isclose(time, 1)
                            ]
                            discharge_resistance_group1_4s = discharge_resistance[
                                np.isclose(time, 4)
                            ]
                            if np.max(time) > 5:
                                discharge_resistance_group1_10s = discharge_resistance[
                                    np.isclose(time, 10)
                                ]
                            else:
                                discharge_resistance_group1_10s = np.NaN
                            # group2
                            discharge_voltage_group2 = voltage_group2
                            discharge_overpotential_group2 = overpotential_group2
                            discharge_resistance = overpotential_group2 / max_current
                            discharge_resistance_group2_0p1s = discharge_resistance[
                                np.isclose(time, 0.1)
                            ]
                            discharge_resistance_group2_1s = discharge_resistance[
                                np.isclose(time, 1)
                            ]
                            discharge_resistance_group2_4s = discharge_resistance[
                                np.isclose(time, 4)
                            ]
                            if np.max(time) > 5:
                                discharge_resistance_group2_10s = discharge_resistance[
                                    np.isclose(time, 10)
                                ]
                            else:
                                discharge_resistance_group2_10s = np.NaN
            # Meta data
            # Temperature of pulse
            temp_mean = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # Rate
            seg_descr = df_seg.loc[1, "Segment Description"]
            if "2C" in seg_descr:
                rate = "2C"
            elif "1C" in seg_descr:
                rate = "1C"
            elif "C/10" in seg_descr:
                rate = "C/10"
            elif "C/2" in seg_descr:
                rate = "C/2"
            # direction
            if "HPPC charge" in seg_descr:
                dir = "charge"
            else:
                dir = "discharge"

            # Store values
            if not flag_series_voltages:
                dat = {
                    "rate": rate,
                    "temp_mean": temp_mean,
                    "soc": soc,
                    "direction": dir,
                    "pulse_time_s": [time],
                    "discharge_current": [discharge_current],
                    "discharge_voltage": [discharge_voltage],
                    "discharge_overpotential": [discharge_overpotential],
                    "discharge_resistance_0p1s": discharge_resistance_0p1s,
                    "discharge_resistance_1s": discharge_resistance_1s,
                    "discharge_resistance_4s": discharge_resistance_4s,
                    "discharge_resistance_10s": discharge_resistance_10s,
                    "charge_current": [charge_current],
                    "charge_voltage": [charge_voltage],
                    "charge_overpotential": [charge_overpotential],
                    "charge_resistance_0p1s": charge_resistance_0p1s,
                    "charge_resistance_1s": charge_resistance_1s,
                    "charge_resistance_4s": charge_resistance_4s,
                    "charge_resistance_10s": charge_resistance_10s,
                    "is_voltage_limit_discharge": is_voltage_limit_discharge,
                    "is_voltage_limit_charge": is_voltage_limit_charge,
                }
            else:
                dat = {
                    "rate": rate,
                    "temp_mean": temp_mean,
                    "soc": soc,
                    "direction": dir,
                    "pulse_time_s": [time],
                    "discharge_current": [discharge_current],
                    "discharge_voltage": [discharge_voltage],
                    "discharge_overpotential": [discharge_overpotential],
                    "discharge_resistance_0p1s": discharge_resistance_0p1s,
                    "discharge_resistance_1s": discharge_resistance_1s,
                    "discharge_resistance_4s": discharge_resistance_4s,
                    "discharge_resistance_10s": discharge_resistance_10s,
                    "discharge_voltage_group1": [discharge_voltage_group1],
                    "discharge_overpotential_group1": [discharge_overpotential_group1],
                    "discharge_resistance_group1_0p1s": discharge_resistance_group1_0p1s,
                    "discharge_resistance_group1_1s": discharge_resistance_group1_1s,
                    "discharge_resistance_group1_4s": discharge_resistance_group1_4s,
                    "discharge_resistance_group1_10s": discharge_resistance_group1_10s,
                    "discharge_voltage_group2": [discharge_voltage_group2],
                    "discharge_overpotential_group2": [discharge_overpotential_group2],
                    "discharge_resistance_group2_0p1s": discharge_resistance_group2_0p1s,
                    "discharge_resistance_group2_1s": discharge_resistance_group2_1s,
                    "discharge_resistance_group2_4s": discharge_resistance_group2_4s,
                    "discharge_resistance_group2_10s": discharge_resistance_group2_10s,
                    "charge_current": [charge_current],
                    "charge_voltage": [charge_voltage],
                    "charge_overpotential": [charge_overpotential],
                    "charge_resistance_0p1s": charge_resistance_0p1s,
                    "charge_resistance_1s": charge_resistance_1s,
                    "charge_resistance_4s": charge_resistance_4s,
                    "charge_resistance_10s": charge_resistance_10s,
                    "charge_voltage_group1": [charge_voltage_group1],
                    "charge_overpotential_group1": [charge_overpotential_group1],
                    "charge_resistance_group1_0p1s": charge_resistance_group1_0p1s,
                    "charge_resistance_group1_1s": charge_resistance_group1_1s,
                    "charge_resistance_group1_4s": charge_resistance_group1_4s,
                    "charge_resistance_group1_10s": charge_resistance_group1_10s,
                    "charge_voltage_group2": [charge_voltage_group2],
                    "charge_overpotential_group2": [charge_overpotential_group2],
                    "charge_resistance_group2_0p1s": charge_resistance_group2_0p1s,
                    "charge_resistance_group2_1s": charge_resistance_group2_1s,
                    "charge_resistance_group2_4s": charge_resistance_group2_4s,
                    "charge_resistance_group2_10s": charge_resistance_group2_10s,
                    "is_voltage_limit_discharge": is_voltage_limit_discharge,
                    "is_voltage_limit_charge": is_voltage_limit_charge,
                }
            if ii == 0:
                out = pd.DataFrame(dat, index=[ii])
            else:
                try:
                    _out = pd.DataFrame(dat, index=[ii])
                    out = pd.concat([out, _out])
                except:
                    # do nothing
                    a = 1

    return out


def get_hppc_pulses(df):
    # For a measurement, return the raw voltage response from every HPPC-type pulse
    # also return meta data, such as temperature during the pulse, and SOC of the pulse
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "HPPC" in seg_desc and "pulses" in seg_desc and not "rapid" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)
    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    time = dfs[0]["Segment Time, S"]
    # voltage and current data column names
    for i, t in enumerate(time):
        if i == 0:
            columns_voltage = ["voltage_%3.1fs" % (t)]
            columns_current = ["current_%3.1fs" % (t)]
        else:
            columns_voltage += ["voltage_%3.1fs" % (t)]
            columns_current += ["current_%3.1fs" % (t)]

    for i, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            df_seg = retime(df_seg)
            voltage = df_seg[col_voltage].to_numpy()
            current = df_seg["Current, A"].to_numpy()
            soc = df_seg["SOC"].to_numpy()
            soc = soc[0]
            # Meta data
            # Temperature of pulse
            temperature = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # Rate
            seg_descr = df_seg.loc[1, "Segment Description"]
            if "2C" in seg_descr:
                rate = "2C"
            elif "1C" in seg_descr:
                rate = "1C"
            elif "C/10" in seg_descr:
                rate = "C/10"
            elif "C/2" in seg_descr:
                rate = "C/2"
            # direction
            if "HPPC charge" in seg_descr:
                direction = "charge"
            else:
                direction = "discharge"

            # instantiate container or concatenate new value
            if voltage.size == 601:
                if i == 0:
                    _soc = soc
                    _temperature = temperature
                    _rate = rate
                    _direction = direction
                    _voltage = voltage
                    _current = current
                else:
                    _soc_ = soc
                    _temperature_ = temperature
                    _rate_ = rate
                    _direction_ = direction
                    _voltage_ = voltage
                    _current_ = current

                    _soc = np.row_stack((_soc, _soc_))
                    _temperature = np.row_stack((_temperature, _temperature_))
                    _rate = np.row_stack((_rate, _rate_))
                    _direction = np.row_stack((_direction, _direction_))
                    _voltage = np.row_stack((_voltage, _voltage_))
                    _current = np.row_stack((_current, _current_))

    out = np.hstack((_soc, _temperature, _rate, _direction, _voltage, _current))
    columns = (
        ["soc", "temperature", "rate", "direction"] + columns_voltage + columns_current
    )
    out = pd.DataFrame(out, columns=columns)
    return out


def get_rapid_pulses(df):
    # For a measurement, return the raw voltage response from every 16s, 'rapid' pulse sequence
    # also return meta data, such as temperature during the pulse, and SOC of the pulse
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "HPPC" in seg_desc and "pulses" in seg_desc and "rapid" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)

    # Rate
    rate = "2C"
    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    time = dfs[0]["Segment Time, S"]
    # voltage and current data column names
    for i, t in enumerate(time):
        if i == 0:
            columns_voltage = ["voltage_%3.1fs" % (t)]
            columns_current = ["current_%3.1fs" % (t)]
        else:
            columns_voltage += ["voltage_%3.1fs" % (t)]
            columns_current += ["current_%3.1fs" % (t)]

    for i, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            df_seg = retime(df_seg)
            voltage = df_seg[col_voltage].to_numpy()
            current = df_seg["Current, A"].to_numpy()
            soc = df_seg["SOC"].to_numpy()
            soc = soc[0]
            # Meta data
            # Temperature of pulse
            temperature = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # direction
            seg_descr = df_seg.loc[1, "Segment Description"]
            if "HPPC charge" in seg_descr:
                direction = "charge"
            else:
                direction = "discharge"

            # instantiate container or concatenate new value
            if voltage.size == 161:
                if i == 0:
                    _soc = soc
                    _temperature = temperature
                    _rate = rate
                    _direction = direction
                    _voltage = voltage
                    _current = current
                else:
                    _soc_ = soc
                    _temperature_ = temperature
                    _rate_ = rate
                    _direction_ = direction
                    _voltage_ = voltage
                    _current_ = current

                    _soc = np.row_stack((_soc, _soc_))
                    _temperature = np.row_stack((_temperature, _temperature_))
                    _rate = np.row_stack((_rate, _rate_))
                    _direction = np.row_stack((_direction, _direction_))
                    _voltage = np.row_stack((_voltage, _voltage_))
                    _current = np.row_stack((_current, _current_))

    out = np.hstack((_soc, _temperature, _rate, _direction, _voltage, _current))
    columns = (
        ["soc", "temperature", "rate", "direction"] + columns_voltage + columns_current
    )
    out = pd.DataFrame(out, columns=columns)
    return out


def get_psrp1_pulses(df):
    # For a measurement, return the raw voltage response from every 'static' PsRP_1 pulse
    # also return meta data, such as temperature during the pulse, and SOC of the pulse
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "HPPC" in seg_desc and "PsRP 1" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)

    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    time = dfs[0]["Segment Time, S"]
    # voltage and current data column names
    for i, t in enumerate(time):
        if i == 0:
            columns_voltage = ["voltage_%3.1fs" % (t)]
            columns_current = ["current_%3.1fs" % (t)]
        else:
            columns_voltage += ["voltage_%3.1fs" % (t)]
            columns_current += ["current_%3.1fs" % (t)]

    for i, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            df_seg = retime(df_seg)
            voltage = df_seg[col_voltage].to_numpy()
            current = df_seg["Current, A"].to_numpy()
            soc = df_seg["SOC"].to_numpy()
            soc = soc[0]
            # Meta data
            # Temperature of pulse
            temperature = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # direction
            seg_descr = df_seg.loc[1, "Segment Description"]
            if "HPPC charge" in seg_descr:
                direction = "charge"
            else:
                direction = "discharge"

            # instantiate container or concatenate new value
            if i == 0:
                _soc = soc
                _temperature = temperature
                _direction = direction
                _voltage = voltage
                _current = current
            else:
                _soc_ = soc
                _temperature_ = temperature
                _direction_ = direction
                _voltage_ = voltage
                _current_ = current
                try:
                    _voltage = np.row_stack((_voltage, _voltage_))
                    _soc = np.row_stack((_soc, _soc_))
                    _temperature = np.row_stack((_temperature, _temperature_))
                    _direction = np.row_stack((_direction, _direction_))
                    _current = np.row_stack((_current, _current_))
                except:
                    # do nothing
                    a = 1
                    # raise Warning('Concatenating pulses failed, check data quality')

    out = np.hstack((_soc, _temperature, _direction, _voltage, _current))
    columns = ["soc", "temperature", "direction"] + columns_voltage + columns_current
    out = pd.DataFrame(out, columns=columns)
    return out


def get_psrp1_Cb2_pulses(df):
    # For a measurement, return the raw voltage response from every 'dynamic' C/2 + PsRP_1 pulse
    # also return meta data, such as temperature during the pulse, SOC of the pulse, and charging/discharging direction
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "PsRP 1 C/2 diagnostic cycle" in seg_desc and "pulse" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)

    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    time = dfs[0]["Segment Time, S"]
    # voltage and current data column names
    for i, t in enumerate(time):
        if i == 0:
            columns_voltage = ["voltage_%3.1fs" % (t)]
            columns_current = ["current_%3.1fs" % (t)]
        else:
            columns_voltage += ["voltage_%3.1fs" % (t)]
            columns_current += ["current_%3.1fs" % (t)]

    for i, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            df_seg = retime(df_seg)
            voltage = df_seg[col_voltage].to_numpy()
            current = df_seg["Current, A"].to_numpy()
            soc = df_seg["SOC"].to_numpy()
            soc = soc[0]
            # Meta data
            # Temperature of pulse
            temperature = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # direction
            seg_descr = df_seg.loc[1, "Segment Description"]
            if "cycle charge" in seg_descr:
                direction = "charge"
            else:
                direction = "discharge"

            # instantiate container or concatenate new value
            if voltage.size == 121:
                if i == 0:
                    _soc = soc
                    _temperature = temperature
                    _direction = direction
                    _voltage = voltage
                    _current = current
                else:
                    _soc_ = soc
                    _temperature_ = temperature
                    _direction_ = direction
                    _voltage_ = voltage
                    _current_ = current

                    _voltage = np.row_stack((_voltage, _voltage_))
                    _soc = np.row_stack((_soc, _soc_))
                    _temperature = np.row_stack((_temperature, _temperature_))
                    _direction = np.row_stack((_direction, _direction_))
                    _current = np.row_stack((_current, _current_))

    out = np.hstack((_soc, _temperature, _direction, _voltage, _current))
    columns = ["soc", "temperature", "direction"] + columns_voltage + columns_current
    out = pd.DataFrame(out, columns=columns)
    return out


def get_psrp1_1C_pulses(df):
    # For a measurement, return the raw voltage response from every 'dynamic' 1C + PsRP_1 pulse
    # also return meta data, such as temperature during the pulse, SOC of the pulse, and charging/discharging direction
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "PsRP 1 1C diagnostic cycle" in seg_desc and "pulse" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)

    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    time = dfs[0]["Segment Time, S"]
    # voltage and current data column names
    for i, t in enumerate(time):
        if i == 0:
            columns_voltage = ["voltage_%3.1fs" % (t)]
            columns_current = ["current_%3.1fs" % (t)]
        else:
            columns_voltage += ["voltage_%3.1fs" % (t)]
            columns_current += ["current_%3.1fs" % (t)]

    for i, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            df_seg = retime(df_seg)
            voltage = df_seg[col_voltage].to_numpy()
            current = df_seg["Current, A"].to_numpy()
            soc = df_seg["SOC"].to_numpy()
            soc = soc[0]
            # Meta data
            # Temperature of pulse
            temperature = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # direction
            seg_descr = df_seg.loc[1, "Segment Description"]
            if "cycle charge" in seg_descr:
                direction = "charge"
            else:
                direction = "discharge"

            # instantiate container or concatenate new value
            if voltage.size == 121:
                if i == 0:
                    _soc = soc
                    _temperature = temperature
                    _direction = direction
                    _voltage = voltage
                    _current = current
                else:
                    _soc_ = soc
                    _temperature_ = temperature
                    _direction_ = direction
                    _voltage_ = voltage
                    _current_ = current

                    _voltage = np.row_stack((_voltage, _voltage_))
                    _soc = np.row_stack((_soc, _soc_))
                    _temperature = np.row_stack((_temperature, _temperature_))
                    _direction = np.row_stack((_direction, _direction_))
                    _current = np.row_stack((_current, _current_))

    out = np.hstack((_soc, _temperature, _direction, _voltage, _current))
    columns = ["soc", "temperature", "direction"] + columns_voltage + columns_current
    out = pd.DataFrame(out, columns=columns)
    return out


def get_psrp2_pulses_charging(df):
    # PSRP 2 WAS NOT SCRIPTED CORRECTLY; CHARGING AND DISCHARGING DIRECTIONS ARE DIFFERENT
    # For a measurement, return the raw voltage response from every 'static' PsRP_2 pulse
    # also return meta data, such as temperature during the pulse, and SOC of the pulse
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "HPPC charge" in seg_desc and "PsRP 2" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)

    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    time = dfs[0]["Segment Time, S"]
    # voltage and current data column names
    for i, t in enumerate(time):
        if i == 0:
            columns_voltage = ["voltage_%3.1fs" % (t)]
            columns_current = ["current_%3.1fs" % (t)]
        else:
            columns_voltage += ["voltage_%3.1fs" % (t)]
            columns_current += ["current_%3.1fs" % (t)]

    for i, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            df_seg = retime(df_seg)
            voltage = df_seg[col_voltage].to_numpy()
            current = df_seg["Current, A"].to_numpy()
            soc = df_seg["SOC"].to_numpy()
            soc = soc[0]
            # Meta data
            # Temperature of pulse
            temperature = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # direction
            direction = "charge"

            # instantiate container or concatenate new value
            if i == 0:
                _soc = soc
                _temperature = temperature
                _direction = direction
                _voltage = voltage
                _current = current
            else:
                _soc_ = soc
                _temperature_ = temperature
                _direction_ = direction
                _voltage_ = voltage
                _current_ = current
                try:
                    _voltage = np.row_stack((_voltage, _voltage_))
                    _soc = np.row_stack((_soc, _soc_))
                    _temperature = np.row_stack((_temperature, _temperature_))
                    _direction = np.row_stack((_direction, _direction_))
                    _current = np.row_stack((_current, _current_))
                except:
                    # do nothing
                    a = 1
                    # raise Warning('Concatenating pulses failed, check data quality')

    out = np.hstack((_soc, _temperature, _direction, _voltage, _current))
    columns = ["soc", "temperature", "direction"] + columns_voltage + columns_current
    out = pd.DataFrame(out, columns=columns)
    return out


def get_psrp2_pulses_discharging(df):
    # PSRP 2 WAS NOT SCRIPTED CORRECTLY; CHARGING AND DISCHARGING DIRECTIONS ARE DIFFERENT
    # For a measurement, return the raw voltage response from every 'static' PsRP_2 pulse
    # also return meta data, such as temperature during the pulse, and SOC of the pulse
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "HPPC discharge" in seg_desc and "PsRP 2" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)

    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    time = dfs[0]["Segment Time, S"]
    # voltage and current data column names
    for i, t in enumerate(time):
        if i == 0:
            columns_voltage = ["voltage_%3.1fs" % (t)]
            columns_current = ["current_%3.1fs" % (t)]
        else:
            columns_voltage += ["voltage_%3.1fs" % (t)]
            columns_current += ["current_%3.1fs" % (t)]

    for i, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            df_seg = retime(df_seg)
            voltage = df_seg[col_voltage].to_numpy()
            current = df_seg["Current, A"].to_numpy()
            soc = df_seg["SOC"].to_numpy()
            soc = soc[0]
            # Meta data
            # Temperature of pulse
            temperature = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # direction
            direction = "discharge"

            # instantiate container or concatenate new value
            if voltage.size == 992:
                if i == 0:
                    _soc = soc
                    _temperature = temperature
                    _direction = direction
                    _voltage = voltage
                    _current = current
                else:
                    _soc_ = soc
                    _temperature_ = temperature
                    _direction_ = direction
                    _voltage_ = voltage
                    _current_ = current

                    _soc = np.row_stack((_soc, _soc_))
                    _temperature = np.row_stack((_temperature, _temperature_))
                    _direction = np.row_stack((_direction, _direction_))
                    _voltage = np.row_stack((_voltage, _voltage_))
                    _current = np.row_stack((_current, _current_))

    out = np.hstack((_soc, _temperature, _direction, _voltage, _current))
    columns = ["soc", "temperature", "direction"] + columns_voltage + columns_current
    out = pd.DataFrame(out, columns=columns)
    return out


def get_psrp2_Cb2_pulses(df):
    # For a measurement, return the raw voltage response from every 'dynamic' C/2 + PsRP_2 pulse
    # also return meta data, such as temperature during the pulse, SOC of the pulse, and charging/discharging direction
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "PsRP 2 C/2 diagnostic cycle" in seg_desc and "pulse" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)

    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    time = dfs[0]["Segment Time, S"]
    # voltage and current data column names
    for i, t in enumerate(time):
        if i == 0:
            columns_voltage = ["voltage_%3.1fs" % (t)]
            columns_current = ["current_%3.1fs" % (t)]
        else:
            columns_voltage += ["voltage_%3.1fs" % (t)]
            columns_current += ["current_%3.1fs" % (t)]

    for i, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            df_seg = retime(df_seg)
            voltage = df_seg[col_voltage].to_numpy()
            current = df_seg["Current, A"].to_numpy()
            soc = df_seg["SOC"].to_numpy()
            soc = soc[0]
            # Meta data
            # Temperature of pulse
            temperature = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # direction
            seg_descr = df_seg.loc[1, "Segment Description"]
            if "cycle charge" in seg_descr:
                direction = "charge"
            else:
                direction = "discharge"

            # instantiate container or concatenate new value
            if voltage.size == 121:
                if i == 0:
                    _soc = soc
                    _temperature = temperature
                    _direction = direction
                    _voltage = voltage
                    _current = current
                else:
                    _soc_ = soc
                    _temperature_ = temperature
                    _direction_ = direction
                    _voltage_ = voltage
                    _current_ = current

                    _soc = np.row_stack((_soc, _soc_))
                    _temperature = np.row_stack((_temperature, _temperature_))
                    _direction = np.row_stack((_direction, _direction_))
                    _voltage = np.row_stack((_voltage, _voltage_))
                    _current = np.row_stack((_current, _current_))

    out = np.hstack((_soc, _temperature, _direction, _voltage, _current))
    columns = ["soc", "temperature", "direction"] + columns_voltage + columns_current
    out = pd.DataFrame(out, columns=columns)
    return out


def get_psrp2_1C_pulses(df):
    # For a measurement, return the raw voltage response from every 'dynamic' 1C + PsRP_2 pulse
    # also return meta data, such as temperature during the pulse, SOC of the pulse, and charging/discharging direction
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "PsRP 2 1C diagnostic cycle" in seg_desc and "pulse" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each pulse segment
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)

    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    time = dfs[0]["Segment Time, S"]
    # voltage and current data column names
    for i, t in enumerate(time):
        if i == 0:
            columns_voltage = ["voltage_%3.1fs" % (t)]
            columns_current = ["current_%3.1fs" % (t)]
        else:
            columns_voltage += ["voltage_%3.1fs" % (t)]
            columns_current += ["current_%3.1fs" % (t)]

    for i, df_seg in enumerate(dfs):
        if df_seg.shape[0] > 1:
            df_seg = retime(df_seg)
            voltage = df_seg[col_voltage].to_numpy()
            current = df_seg["Current, A"].to_numpy()
            soc = df_seg["SOC"].to_numpy()
            soc = soc[0]
            # Meta data
            # Temperature of pulse
            temperature = np.mean(df_seg["Temperature A1, °C"].to_numpy())
            # direction
            seg_descr = df_seg.loc[1, "Segment Description"]
            if "cycle charge" in seg_descr:
                direction = "charge"
            else:
                direction = "discharge"

            # instantiate container or concatenate new value
            if voltage.size == 121:
                if i == 0:
                    _soc = soc
                    _temperature = temperature
                    _direction = direction
                    _voltage = voltage
                    _current = current
                else:
                    _soc_ = soc
                    _temperature_ = temperature
                    _direction_ = direction
                    _voltage_ = voltage
                    _current_ = current

                    _soc = np.row_stack((_soc, _soc_))
                    _temperature = np.row_stack((_temperature, _temperature_))
                    _direction = np.row_stack((_direction, _direction_))
                    _voltage = np.row_stack((_voltage, _voltage_))
                    _current = np.row_stack((_current, _current_))

    out = np.hstack((_soc, _temperature, _direction, _voltage, _current))
    columns = ["soc", "temperature", "direction"] + columns_voltage + columns_current
    out = pd.DataFrame(out, columns=columns)
    return out


def get_after_charge_rests(df):
    # For a measurement, return the raw voltage response of the post-charge rests
    # return meta data like temperature and the rate of the charge
    if any(["Cell Voltage A1" in col for col in df.columns]):
        col_voltage = "Cell Voltage A1, V"
    else:
        col_voltage = "Voltage, V"

    is_pulse = [
        "Rate test" in seg_desc and "after charge rest" in seg_desc
        for seg_desc in df["Segment Description"]
    ]
    # Have to include 1 data point before start of each rest segment (to get initial voltage drop)
    mask_priorvoltage = [False] * len(is_pulse)
    in_chunk = False
    for i, value in enumerate(is_pulse):
        if value and not in_chunk:
            mask_priorvoltage[i - 1] = True
            in_chunk = True
        elif not value:
            in_chunk = False
    is_pulse = np.logical_or(is_pulse, mask_priorvoltage)

    # Separate pulses into dfs, process each pulse
    dfs = get_segment_parts(df[is_pulse])
    return dfs


def join_targets_to_features(features_raw, targets_raw_all):
    # Append all targets to the feature data, joining by "measurement_id"
    cols_keep = [
        (
            "soc" in var
            or "temperature_ambient" in var
            or "rate" in var
            or "direction" in var
            or "measurement_id" in var
            or var == "1s"
            or var == "10s"
            or var == "0p1s"
            or var == "4s"
        )
        or ("voltage" in var or "current" in var or "temperature" in var)
        and ".0s" in var
        for var in features_raw.columns
    ]
    features = features_raw.iloc[:, cols_keep]
    features_and_targets = features.join(
        targets_raw_all, on="measurement_id", how="left", lsuffix="_f"
    )
    features_and_targets = features_and_targets.drop(columns=["measurement_id_f"])
    return features_and_targets
